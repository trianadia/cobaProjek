{"version":3,"file":"prisma-adapter.mjs","names":["lazyOptions: BetterAuthOptions | null","prisma","result: Record<string, Record<string, any> | boolean>","schema","e: any","adapterOptions: AdapterFactoryOptions | null"],"sources":["../../../src/adapters/prisma-adapter/prisma-adapter.ts"],"sourcesContent":["import type { BetterAuthOptions } from \"@better-auth/core\";\nimport type {\n\tAdapterFactoryCustomizeAdapterCreator,\n\tAdapterFactoryOptions,\n\tDBAdapter,\n\tDBAdapterDebugLogOption,\n\tJoinConfig,\n\tWhere,\n} from \"@better-auth/core/db/adapter\";\nimport { createAdapterFactory } from \"@better-auth/core/db/adapter\";\nimport { BetterAuthError } from \"@better-auth/core/error\";\n\nexport interface PrismaConfig {\n\t/**\n\t * Database provider.\n\t */\n\tprovider:\n\t\t| \"sqlite\"\n\t\t| \"cockroachdb\"\n\t\t| \"mysql\"\n\t\t| \"postgresql\"\n\t\t| \"sqlserver\"\n\t\t| \"mongodb\";\n\n\t/**\n\t * Enable debug logs for the adapter\n\t *\n\t * @default false\n\t */\n\tdebugLogs?: DBAdapterDebugLogOption | undefined;\n\n\t/**\n\t * Use plural table names\n\t *\n\t * @default false\n\t */\n\tusePlural?: boolean | undefined;\n\n\t/**\n\t * Whether to execute multiple operations in a transaction.\n\t *\n\t * If the database doesn't support transactions,\n\t * set this to `false` and operations will be executed sequentially.\n\t * @default false\n\t */\n\ttransaction?: boolean | undefined;\n}\n\ninterface PrismaClient {}\n\ntype PrismaClientInternal = {\n\t$transaction: (\n\t\tcallback: (db: PrismaClient) => Promise<any> | any,\n\t) => Promise<any>;\n} & {\n\t[model: string]: {\n\t\tcreate: (data: any) => Promise<any>;\n\t\tfindFirst: (data: any) => Promise<any>;\n\t\tfindMany: (data: any) => Promise<any>;\n\t\tupdate: (data: any) => Promise<any>;\n\t\tupdateMany: (data: any) => Promise<any>;\n\t\tdelete: (data: any) => Promise<any>;\n\t\t[key: string]: any;\n\t};\n};\n\nexport const prismaAdapter = (prisma: PrismaClient, config: PrismaConfig) => {\n\tlet lazyOptions: BetterAuthOptions | null = null;\n\tconst createCustomAdapter =\n\t\t(prisma: PrismaClient): AdapterFactoryCustomizeAdapterCreator =>\n\t\t({\n\t\t\tgetFieldName,\n\t\t\tgetModelName,\n\t\t\tgetFieldAttributes,\n\t\t\tgetDefaultModelName,\n\t\t\tschema,\n\t\t}) => {\n\t\t\tconst db = prisma as PrismaClientInternal;\n\n\t\t\tconst convertSelect = (\n\t\t\t\tselect: string[] | undefined,\n\t\t\t\tmodel: string,\n\t\t\t\tjoin?: JoinConfig | undefined,\n\t\t\t) => {\n\t\t\t\tif (!select && !join) return undefined;\n\n\t\t\t\tlet result: Record<string, Record<string, any> | boolean> = {};\n\n\t\t\t\tif (select) {\n\t\t\t\t\tfor (const field of select) {\n\t\t\t\t\t\tresult[getFieldName({ model, field })] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (join) {\n\t\t\t\t\t// when joining that has a limit, we need to use Prisma's `select` syntax to append the limit to the field\n\t\t\t\t\t// because of such, it also means we need to select all base-model fields as well\n\t\t\t\t\t// should check if `select` is not provided, because then we should select all base-model fields\n\t\t\t\t\tif (!select) {\n\t\t\t\t\t\tconst fields = schema[getDefaultModelName(model)]?.fields || {};\n\t\t\t\t\t\tfields.id = { type: \"string\" }; // make sure there is at least an id field\n\t\t\t\t\t\tfor (const field of Object.keys(fields)) {\n\t\t\t\t\t\t\tresult[getFieldName({ model, field })] = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tfor (const [joinModel, joinAttr] of Object.entries(join)) {\n\t\t\t\t\t\tconst key = getJoinKeyName(model, getModelName(joinModel), schema);\n\t\t\t\t\t\tif (joinAttr.relation === \"one-to-one\") {\n\t\t\t\t\t\t\tresult[key] = true;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tresult[key] = { take: joinAttr.limit };\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn result;\n\t\t\t};\n\n\t\t\t/**\n\t\t\t * Build the join key name based on whether the foreign field is unique or not.\n\t\t\t * If unique, use singular. Otherwise, pluralize (add 's').\n\t\t\t */\n\t\t\tconst getJoinKeyName = (\n\t\t\t\tbaseModel: string,\n\t\t\t\tjoinedModel: string,\n\t\t\t\tschema: any,\n\t\t\t): string => {\n\t\t\t\ttry {\n\t\t\t\t\tconst defaultBaseModelName = getDefaultModelName(baseModel);\n\t\t\t\t\tconst defaultJoinedModelName = getDefaultModelName(joinedModel);\n\t\t\t\t\tconst key = getModelName(joinedModel).toLowerCase();\n\n\t\t\t\t\t// First, check if the joined model has FKs to the base model (forward join)\n\t\t\t\t\tlet foreignKeys = Object.entries(\n\t\t\t\t\t\tschema[defaultJoinedModelName]?.fields || {},\n\t\t\t\t\t).filter(\n\t\t\t\t\t\t([_field, fieldAttributes]: any) =>\n\t\t\t\t\t\t\tfieldAttributes.references &&\n\t\t\t\t\t\t\tgetDefaultModelName(fieldAttributes.references.model) ===\n\t\t\t\t\t\t\t\tdefaultBaseModelName,\n\t\t\t\t\t);\n\n\t\t\t\t\tif (foreignKeys.length > 0) {\n\t\t\t\t\t\t// Forward join: joined model has FK to base model\n\t\t\t\t\t\t// This is typically a one-to-many relationship (plural)\n\t\t\t\t\t\t// Unless the FK is unique, then it's one-to-one (singular)\n\t\t\t\t\t\tconst [_foreignKey, foreignKeyAttributes] = foreignKeys[0] as any;\n\t\t\t\t\t\t// Only check if field is explicitly marked as unique\n\t\t\t\t\t\tconst isUnique = foreignKeyAttributes?.unique === true;\n\t\t\t\t\t\treturn isUnique || config.usePlural === true ? key : `${key}s`;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Check backwards: does the base model have FKs to the joined model?\n\t\t\t\t\tforeignKeys = Object.entries(\n\t\t\t\t\t\tschema[defaultBaseModelName]?.fields || {},\n\t\t\t\t\t).filter(\n\t\t\t\t\t\t([_field, fieldAttributes]: any) =>\n\t\t\t\t\t\t\tfieldAttributes.references &&\n\t\t\t\t\t\t\tgetDefaultModelName(fieldAttributes.references.model) ===\n\t\t\t\t\t\t\t\tdefaultJoinedModelName,\n\t\t\t\t\t);\n\n\t\t\t\t\tif (foreignKeys.length > 0) {\n\t\t\t\t\t\treturn key;\n\t\t\t\t\t}\n\t\t\t\t} catch {\n\t\t\t\t\t// Fallback to pluralizing if we can't determine uniqueness\n\t\t\t\t}\n\t\t\t\treturn `${getModelName(joinedModel).toLowerCase()}s`;\n\t\t\t};\n\t\t\tfunction operatorToPrismaOperator(operator: string) {\n\t\t\t\tswitch (operator) {\n\t\t\t\t\tcase \"starts_with\":\n\t\t\t\t\t\treturn \"startsWith\";\n\t\t\t\t\tcase \"ends_with\":\n\t\t\t\t\t\treturn \"endsWith\";\n\t\t\t\t\tcase \"ne\":\n\t\t\t\t\t\treturn \"not\";\n\t\t\t\t\tcase \"not_in\":\n\t\t\t\t\t\treturn \"notIn\";\n\t\t\t\t\tdefault:\n\t\t\t\t\t\treturn operator;\n\t\t\t\t}\n\t\t\t}\n\t\t\tconst convertWhereClause = (\n\t\t\t\tmodel: string,\n\t\t\t\twhere?: Where[] | undefined,\n\t\t\t) => {\n\t\t\t\tif (!where || !where.length) return {};\n\t\t\t\tconst buildSingleCondition = (w: Where) => {\n\t\t\t\t\tconst fieldName = getFieldName({ model, field: w.field });\n\t\t\t\t\t// Special handling for Prisma null semantics, for non-nullable fields this is a tautology. Skip condition.\n\t\t\t\t\tif (w.operator === \"ne\" && w.value === null) {\n\t\t\t\t\t\treturn {};\n\t\t\t\t\t}\n\t\t\t\t\tif (\n\t\t\t\t\t\t(w.operator === \"in\" || w.operator === \"not_in\") &&\n\t\t\t\t\t\tArray.isArray(w.value)\n\t\t\t\t\t) {\n\t\t\t\t\t\tconst filtered = w.value.filter((v) => v != null);\n\t\t\t\t\t\tif (filtered.length === 0) {\n\t\t\t\t\t\t\tif (w.operator === \"in\") {\n\t\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\t\tAND: [\n\t\t\t\t\t\t\t\t\t\t{ [fieldName]: { equals: \"__never__\" } },\n\t\t\t\t\t\t\t\t\t\t{ [fieldName]: { not: \"__never__\" } },\n\t\t\t\t\t\t\t\t\t],\n\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\treturn {};\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tconst prismaOp = operatorToPrismaOperator(w.operator);\n\t\t\t\t\t\treturn { [fieldName]: { [prismaOp]: filtered } };\n\t\t\t\t\t}\n\t\t\t\t\tif (w.operator === \"eq\" || !w.operator) {\n\t\t\t\t\t\treturn { [fieldName]: w.value };\n\t\t\t\t\t}\n\t\t\t\t\treturn {\n\t\t\t\t\t\t[fieldName]: {\n\t\t\t\t\t\t\t[operatorToPrismaOperator(w.operator)]: w.value,\n\t\t\t\t\t\t},\n\t\t\t\t\t};\n\t\t\t\t};\n\t\t\t\tif (where.length === 1) {\n\t\t\t\t\tconst w = where[0]!;\n\t\t\t\t\tif (!w) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\treturn buildSingleCondition(w);\n\t\t\t\t}\n\t\t\t\tconst and = where.filter((w) => w.connector === \"AND\" || !w.connector);\n\t\t\t\tconst or = where.filter((w) => w.connector === \"OR\");\n\t\t\t\tconst andClause = and.map((w) => buildSingleCondition(w));\n\t\t\t\tconst orClause = or.map((w) => buildSingleCondition(w));\n\n\t\t\t\treturn {\n\t\t\t\t\t...(andClause.length ? { AND: andClause } : {}),\n\t\t\t\t\t...(orClause.length ? { OR: orClause } : {}),\n\t\t\t\t};\n\t\t\t};\n\n\t\t\treturn {\n\t\t\t\tasync create({ model, data: values, select }) {\n\t\t\t\t\tif (!db[model]) {\n\t\t\t\t\t\tthrow new BetterAuthError(\n\t\t\t\t\t\t\t`Model ${model} does not exist in the database. If you haven't generated the Prisma client, you need to run 'npx prisma generate'`,\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t\tconst result = await db[model]!.create({\n\t\t\t\t\t\tdata: values,\n\t\t\t\t\t\tselect: convertSelect(select, model),\n\t\t\t\t\t});\n\t\t\t\t\treturn result;\n\t\t\t\t},\n\t\t\t\tasync findOne({ model, where, select, join }) {\n\t\t\t\t\t// this is just \"JoinOption\" type because we disabled join transformation in adapter config\n\t\t\t\t\tconst whereClause = convertWhereClause(model, where);\n\t\t\t\t\tif (!db[model]) {\n\t\t\t\t\t\tthrow new BetterAuthError(\n\t\t\t\t\t\t\t`Model ${model} does not exist in the database. If you haven't generated the Prisma client, you need to run 'npx prisma generate'`,\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\n\t\t\t\t\t// transform join keys to use Prisma expected field names\n\t\t\t\t\tlet map = new Map<string, string>();\n\t\t\t\t\tfor (const joinModel of Object.keys(join ?? {})) {\n\t\t\t\t\t\tconst key = getJoinKeyName(model, joinModel, schema);\n\t\t\t\t\t\tmap.set(key, getModelName(joinModel));\n\t\t\t\t\t}\n\n\t\t\t\t\tconst selects = convertSelect(select, model, join);\n\n\t\t\t\t\tlet result = await db[model]!.findFirst({\n\t\t\t\t\t\twhere: whereClause,\n\t\t\t\t\t\tselect: selects,\n\t\t\t\t\t});\n\n\t\t\t\t\t// transform the resulting `include` items to use better-auth expected field names\n\t\t\t\t\tif (join && result) {\n\t\t\t\t\t\tfor (const [includeKey, originalKey] of map.entries()) {\n\t\t\t\t\t\t\tif (includeKey === originalKey) continue;\n\t\t\t\t\t\t\tif (includeKey in result) {\n\t\t\t\t\t\t\t\tresult[originalKey] = result[includeKey];\n\t\t\t\t\t\t\t\tdelete result[includeKey];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn result;\n\t\t\t\t},\n\t\t\t\tasync findMany({ model, where, limit, offset, sortBy, join }) {\n\t\t\t\t\t// this is just \"JoinOption\" type because we disabled join transformation in adapter config\n\t\t\t\t\tconst whereClause = convertWhereClause(model, where);\n\t\t\t\t\tif (!db[model]) {\n\t\t\t\t\t\tthrow new BetterAuthError(\n\t\t\t\t\t\t\t`Model ${model} does not exist in the database. If you haven't generated the Prisma client, you need to run 'npx prisma generate'`,\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t\t// transform join keys to use Prisma expected field names\n\t\t\t\t\tlet map = new Map<string, string>();\n\t\t\t\t\tif (join) {\n\t\t\t\t\t\tfor (const [joinModel, _value] of Object.entries(join)) {\n\t\t\t\t\t\t\tconst key = getJoinKeyName(model, joinModel, schema);\n\t\t\t\t\t\t\tmap.set(key, getModelName(joinModel));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tconst selects = convertSelect(undefined, model, join);\n\n\t\t\t\t\tconst result = await db[model]!.findMany({\n\t\t\t\t\t\twhere: whereClause,\n\t\t\t\t\t\ttake: limit || 100,\n\t\t\t\t\t\tskip: offset || 0,\n\t\t\t\t\t\t...(sortBy?.field\n\t\t\t\t\t\t\t? {\n\t\t\t\t\t\t\t\t\torderBy: {\n\t\t\t\t\t\t\t\t\t\t[getFieldName({ model, field: sortBy.field })]:\n\t\t\t\t\t\t\t\t\t\t\tsortBy.direction === \"desc\" ? \"desc\" : \"asc\",\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t: {}),\n\t\t\t\t\t\tselect: selects,\n\t\t\t\t\t});\n\n\t\t\t\t\t// transform the resulting join items to use better-auth expected field names\n\t\t\t\t\tif (join && Array.isArray(result)) {\n\t\t\t\t\t\tfor (const item of result) {\n\t\t\t\t\t\t\tfor (const [includeKey, originalKey] of map.entries()) {\n\t\t\t\t\t\t\t\tif (includeKey === originalKey) continue;\n\t\t\t\t\t\t\t\tif (includeKey in item) {\n\t\t\t\t\t\t\t\t\titem[originalKey] = item[includeKey];\n\t\t\t\t\t\t\t\t\tdelete item[includeKey];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\treturn result;\n\t\t\t\t},\n\t\t\t\tasync count({ model, where }) {\n\t\t\t\t\tconst whereClause = convertWhereClause(model, where);\n\t\t\t\t\tif (!db[model]) {\n\t\t\t\t\t\tthrow new BetterAuthError(\n\t\t\t\t\t\t\t`Model ${model} does not exist in the database. If you haven't generated the Prisma client, you need to run 'npx prisma generate'`,\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t\treturn await db[model]!.count({\n\t\t\t\t\t\twhere: whereClause,\n\t\t\t\t\t});\n\t\t\t\t},\n\t\t\t\tasync update({ model, where, update }) {\n\t\t\t\t\tif (!db[model]) {\n\t\t\t\t\t\tthrow new BetterAuthError(\n\t\t\t\t\t\t\t`Model ${model} does not exist in the database. If you haven't generated the Prisma client, you need to run 'npx prisma generate'`,\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t\tconst whereClause = convertWhereClause(model, where);\n\t\t\t\t\treturn await db[model]!.update({\n\t\t\t\t\t\twhere: whereClause,\n\t\t\t\t\t\tdata: update,\n\t\t\t\t\t});\n\t\t\t\t},\n\t\t\t\tasync updateMany({ model, where, update }) {\n\t\t\t\t\tif (!db[model]) {\n\t\t\t\t\t\tthrow new BetterAuthError(\n\t\t\t\t\t\t\t`Model ${model} does not exist in the database. If you haven't generated the Prisma client, you need to run 'npx prisma generate'`,\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t\tconst whereClause = convertWhereClause(model, where);\n\t\t\t\t\tconst result = await db[model]!.updateMany({\n\t\t\t\t\t\twhere: whereClause,\n\t\t\t\t\t\tdata: update,\n\t\t\t\t\t});\n\t\t\t\t\treturn result ? (result.count as number) : 0;\n\t\t\t\t},\n\t\t\t\tasync delete({ model, where }) {\n\t\t\t\t\tif (!db[model]) {\n\t\t\t\t\t\tthrow new BetterAuthError(\n\t\t\t\t\t\t\t`Model ${model} does not exist in the database. If you haven't generated the Prisma client, you need to run 'npx prisma generate'`,\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t\tconst whereClause = convertWhereClause(model, where);\n\t\t\t\t\ttry {\n\t\t\t\t\t\tawait db[model]!.delete({\n\t\t\t\t\t\t\twhere: whereClause,\n\t\t\t\t\t\t});\n\t\t\t\t\t} catch (e: any) {\n\t\t\t\t\t\t// If the record doesn't exist, we don't want to throw an error\n\t\t\t\t\t\tif (e?.meta?.cause === \"Record to delete does not exist.\") return;\n\t\t\t\t\t\t// otherwise if it's an unknown error, we want to just log it for debugging.\n\t\t\t\t\t\tconsole.log(e);\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tasync deleteMany({ model, where }) {\n\t\t\t\t\tconst whereClause = convertWhereClause(model, where);\n\t\t\t\t\tconst result = await db[model]!.deleteMany({\n\t\t\t\t\t\twhere: whereClause,\n\t\t\t\t\t});\n\t\t\t\t\treturn result ? (result.count as number) : 0;\n\t\t\t\t},\n\t\t\t\toptions: config,\n\t\t\t};\n\t\t};\n\n\tlet adapterOptions: AdapterFactoryOptions | null = null;\n\tadapterOptions = {\n\t\tconfig: {\n\t\t\tadapterId: \"prisma\",\n\t\t\tadapterName: \"Prisma Adapter\",\n\t\t\tusePlural: config.usePlural ?? false,\n\t\t\tdebugLogs: config.debugLogs ?? false,\n\t\t\tsupportsUUIDs: config.provider === \"postgresql\" ? true : false,\n\t\t\tsupportsArrays:\n\t\t\t\tconfig.provider === \"postgresql\" || config.provider === \"mongodb\"\n\t\t\t\t\t? true\n\t\t\t\t\t: false,\n\t\t\ttransaction:\n\t\t\t\t(config.transaction ?? false)\n\t\t\t\t\t? (cb) =>\n\t\t\t\t\t\t\t(prisma as PrismaClientInternal).$transaction((tx) => {\n\t\t\t\t\t\t\t\tconst adapter = createAdapterFactory({\n\t\t\t\t\t\t\t\t\tconfig: adapterOptions!.config,\n\t\t\t\t\t\t\t\t\tadapter: createCustomAdapter(tx),\n\t\t\t\t\t\t\t\t})(lazyOptions!);\n\t\t\t\t\t\t\t\treturn cb(adapter);\n\t\t\t\t\t\t\t})\n\t\t\t\t\t: false,\n\t\t},\n\t\tadapter: createCustomAdapter(prisma),\n\t};\n\n\tconst adapter = createAdapterFactory(adapterOptions);\n\treturn (options: BetterAuthOptions): DBAdapter<BetterAuthOptions> => {\n\t\tlazyOptions = options;\n\t\treturn adapter(options);\n\t};\n};\n"],"mappings":"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"}