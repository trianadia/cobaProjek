{"version":3,"file":"schema.mjs","names":["parsedData: Record<string, any>","schema: Record<string, DBFieldAttribute>"],"sources":["../../src/db/schema.ts"],"sourcesContent":["import type { BetterAuthOptions } from \"@better-auth/core\";\nimport type {\n\tBetterAuthPluginDBSchema,\n\tDBFieldAttribute,\n} from \"@better-auth/core/db\";\nimport { APIError } from \"better-call\";\nimport type { Account, Session, User } from \"../types\";\n\n// Cache for parsed schemas to avoid reparsing on every request\nconst cache = new WeakMap<\n\tBetterAuthOptions,\n\tMap<string, Record<string, DBFieldAttribute>>\n>();\n\nfunction parseOutputData<T extends Record<string, any>>(\n\tdata: T,\n\tschema: {\n\t\tfields: Record<string, DBFieldAttribute>;\n\t},\n) {\n\tconst fields = schema.fields;\n\tconst parsedData: Record<string, any> = {};\n\tfor (const key in data) {\n\t\tconst field = fields[key];\n\t\tif (!field) {\n\t\t\tparsedData[key] = data[key];\n\t\t\tcontinue;\n\t\t}\n\t\tif (field.returned === false) {\n\t\t\tcontinue;\n\t\t}\n\t\tparsedData[key] = data[key];\n\t}\n\treturn parsedData as T;\n}\n\nfunction getAllFields(options: BetterAuthOptions, table: string) {\n\tif (!cache.has(options)) {\n\t\tcache.set(options, new Map());\n\t}\n\tconst tableCache = cache.get(options)!;\n\tif (tableCache.has(table)) {\n\t\treturn tableCache.get(table)!;\n\t}\n\tlet schema: Record<string, DBFieldAttribute> = {\n\t\t...(table === \"user\" ? options.user?.additionalFields : {}),\n\t\t...(table === \"session\" ? options.session?.additionalFields : {}),\n\t};\n\tfor (const plugin of options.plugins || []) {\n\t\tif (plugin.schema && plugin.schema[table]) {\n\t\t\tschema = {\n\t\t\t\t...schema,\n\t\t\t\t...plugin.schema[table].fields,\n\t\t\t};\n\t\t}\n\t}\n\tcache.get(options)!.set(table, schema);\n\treturn schema;\n}\n\nexport function parseUserOutput(options: BetterAuthOptions, user: User) {\n\tconst schema = getAllFields(options, \"user\");\n\treturn {\n\t\t...parseOutputData(user, { fields: schema }),\n\t\tid: user.id,\n\t};\n}\n\nexport function parseAccountOutput(\n\toptions: BetterAuthOptions,\n\taccount: Account,\n) {\n\tconst schema = getAllFields(options, \"account\");\n\treturn parseOutputData(account, { fields: schema });\n}\n\nexport function parseSessionOutput(\n\toptions: BetterAuthOptions,\n\tsession: Session,\n) {\n\tconst schema = getAllFields(options, \"session\");\n\treturn parseOutputData(session, { fields: schema });\n}\n\nexport function parseInputData<T extends Record<string, any>>(\n\tdata: T,\n\tschema: {\n\t\tfields: Record<string, DBFieldAttribute>;\n\t\taction?: (\"create\" | \"update\") | undefined;\n\t},\n) {\n\tconst action = schema.action || \"create\";\n\tconst fields = schema.fields;\n\tconst parsedData: Record<string, any> = Object.assign(\n\t\tObject.create(null),\n\t\tnull,\n\t);\n\tfor (const key in fields) {\n\t\tif (key in data) {\n\t\t\tif (fields[key]!.input === false) {\n\t\t\t\tif (fields[key]!.defaultValue !== undefined) {\n\t\t\t\t\tif (action !== \"update\") {\n\t\t\t\t\t\tparsedData[key] = fields[key]!.defaultValue;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (data[key]) {\n\t\t\t\t\tthrow new APIError(\"BAD_REQUEST\", {\n\t\t\t\t\t\tmessage: `${key} is not allowed to be set`,\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (fields[key]!.validator?.input && data[key] !== undefined) {\n\t\t\t\tconst result = fields[key]!.validator.input[\"~standard\"].validate(\n\t\t\t\t\tdata[key],\n\t\t\t\t);\n\t\t\t\tif (result instanceof Promise) {\n\t\t\t\t\tthrow new APIError(\"INTERNAL_SERVER_ERROR\", {\n\t\t\t\t\t\tmessage: \"Async validation is not supported for additional fields\",\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\tif (\"issues\" in result && result.issues) {\n\t\t\t\t\tthrow new APIError(\"BAD_REQUEST\", {\n\t\t\t\t\t\tmessage: result.issues[0]?.message || \"Validation Error\",\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\tparsedData[key] = result.value;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (fields[key]!.transform?.input && data[key] !== undefined) {\n\t\t\t\tparsedData[key] = fields[key]!.transform?.input(data[key]);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tparsedData[key] = data[key];\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (fields[key]!.defaultValue !== undefined && action === \"create\") {\n\t\t\tif (typeof fields[key]!.defaultValue === \"function\") {\n\t\t\t\tparsedData[key] = fields[key]!.defaultValue();\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tparsedData[key] = fields[key]!.defaultValue;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (fields[key]!.required && action === \"create\") {\n\t\t\tthrow new APIError(\"BAD_REQUEST\", {\n\t\t\t\tmessage: `${key} is required`,\n\t\t\t});\n\t\t}\n\t}\n\treturn parsedData as Partial<T>;\n}\n\nexport function parseUserInput(\n\toptions: BetterAuthOptions,\n\tuser: Record<string, any> = {},\n\taction: \"create\" | \"update\",\n) {\n\tconst schema = getAllFields(options, \"user\");\n\treturn parseInputData(user, { fields: schema, action });\n}\n\nexport function parseAdditionalUserInput(\n\toptions: BetterAuthOptions,\n\tuser?: Record<string, any> | undefined,\n) {\n\tconst schema = getAllFields(options, \"user\");\n\treturn parseInputData(user || {}, { fields: schema });\n}\n\nexport function parseAccountInput(\n\toptions: BetterAuthOptions,\n\taccount: Partial<Account>,\n) {\n\tconst schema = getAllFields(options, \"account\");\n\treturn parseInputData(account, { fields: schema });\n}\n\nexport function parseSessionInput(\n\toptions: BetterAuthOptions,\n\tsession: Partial<Session>,\n) {\n\tconst schema = getAllFields(options, \"session\");\n\treturn parseInputData(session, { fields: schema });\n}\n\nexport function mergeSchema<S extends BetterAuthPluginDBSchema>(\n\tschema: S,\n\tnewSchema?:\n\t\t| {\n\t\t\t\t[K in keyof S]?:\n\t\t\t\t\t| {\n\t\t\t\t\t\t\tmodelName?: string | undefined;\n\t\t\t\t\t\t\tfields?:\n\t\t\t\t\t\t\t\t| {\n\t\t\t\t\t\t\t\t\t\t[P: string]: string;\n\t\t\t\t\t\t\t\t  }\n\t\t\t\t\t\t\t\t| undefined;\n\t\t\t\t\t  }\n\t\t\t\t\t| undefined;\n\t\t  }\n\t\t| undefined,\n) {\n\tif (!newSchema) {\n\t\treturn schema;\n\t}\n\tfor (const table in newSchema) {\n\t\tconst newModelName = newSchema[table]?.modelName;\n\t\tif (newModelName) {\n\t\t\tschema[table]!.modelName = newModelName;\n\t\t}\n\t\tfor (const field in schema[table]!.fields) {\n\t\t\tconst newField = newSchema[table]?.fields?.[field];\n\t\t\tif (!newField) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tschema[table]!.fields[field]!.fieldName = newField;\n\t\t}\n\t}\n\treturn schema;\n}\n"],"mappings":"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"}